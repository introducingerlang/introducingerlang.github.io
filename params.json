{"name":"Introducing Erlang","tagline":"From Install to First Working App in 30 minutes","body":"# Introducing Erlang #\r\nThe goal of this website is to get Erlang installed on your system and write a\r\nnon-trivial working application in 30 minutes.  Through this we aim to show a\r\ngentle introduction to a carefully chosen set of Erlang's features so you can\r\ndecide if Erlang is a good language for your needs.\r\n\r\n## Benefits of Erlang ##\r\n\r\nErlang makes hard concurrency and distributed system problems easier to\r\nimplement.  Some of the great things Erlang offers include:\r\n\r\n* Mature idioms for writing inherently scalable network services.\r\n* Great support for slicing and dicing network protocols/packets.\r\n* A \"shared nothing\" concurrency model which lends itself to easy reasoning.\r\n* Linear multicore performance (up to about 8 cores) with soft real-time responsiveness.\r\n* Baked in distributed communication across systems.\r\n* Mechanisms to monitor and automatically restart failed processes.\r\n* Replace / upgrade running code without any downtime.\r\n* A friendly and welcoming user community.\r\n\r\nSome of the drawbacks include:\r\n\r\n* A lack of broad library support.\r\n* It can have a steep learning curve.\r\n* A lack of newbie-approachable documentation. \r\n  (One of the goals of this website is to help correct this.)\r\n* String support can be irritating.\r\n* It is not an especially fast language when handling CPU bound computational tasks.\r\n\r\nStill the positives greatly outweigh the negatives and library support seems to improve\r\nconstantly.\r\n\r\n## Installing Erlang ##\r\n[Precompiled binaries][0] are available for:\r\n\r\n* Windows\r\n* Mac OS X\r\n* Ubuntu, Debian, Fedora and CentOS\r\n\r\nIf you prefer to install Erlang from source, we recommend you use a tool like [kerl][1] which offers the same kind of isolation for Erlang environments that a tool like virtualenv brings to Python.  Installation using kerl is straight forward:\r\n\r\n     $ curl -O https://raw.github.com/spawngrid/kerl/master/kerl\r\n     $ chmod a+x kerl\r\n     $ ./kerl update releases\r\n     $ ./kerl build R16B03-1 r16b03-1\r\n     $ ./kerl install r16b03-1 ~/erlang/r16b03-1\r\n     $ ~/erlang/r16b03-1/activate\r\n\r\nWhich ever way you install Erlang, it's a good idea to test that the Erlang REPL is in your path.  You start the Erlang REPL by using the command `erl`.  You should see something like:\r\n\r\n     $ erl\r\n     Erlang R16B03 (erts-5.10.4) [source] [64-bit] [smp:8:8] [async-threads:0] [kernel-poll:false]\r\n\r\n     Eshell V5.10.4  (abort with ^G)\r\n     1> \r\n\r\nThe `1>` prompt is your opportunity to start with a simple Erlang expression.\r\n\r\n     1> \"Hello world!\".\r\n     \"Hello world!\"\r\n     2> 2 + 2.\r\n     4\r\n     3> random:uniform(1000).\r\n     444\r\n\r\nLike my fourth grade English teacher, Erlang cares a lot about periods. A period is how the Erlang parser knows you've finished an expression.  If you forget to put one on the end of an expression, the REPL will not return a value.\r\n\r\n     5> forgotten_period\r\n     5> \r\n\r\nNotice that the REPL doesn't increment the command counter; that's a subtle clue its still on expression 5. To complete the expression, you can just enter a single period `.` and hit enter.\r\n\r\n     5> forgotten_period \r\n     5> .\r\n     forgotten_period\r\n\r\nWhen you're tired of playing around with simple expressions, you can exit the REPL by executing the `q().` function which tells the REPL to quit and terminate the Erlang VM.\r\n\r\n## Quick note on assignment ##\r\nErlang has immutable variables.  Once a variable name is bound to a value,\r\nErlang will also \"see\" the bound value which can never be updated. \r\n\r\nI know this sounds crazy to a programmer used to a traditional mutable\r\nvariable, but it turns out to be far less of a hassle than you might think in\r\npractice.\r\n\r\nLet's take a common Erlang data structure, a property list, as an example.\r\n\r\nA property list is a list of tagged tuples in the form `{Key, Value}` where\r\nthe Key and the Value can be arbitrary Erlang terms (including another proplist).\r\n\r\n    Proplist = [{foo, 42}, {bar, true}, {qux, \"Hello!\"}].\r\n\r\nLet's remove one of the elements from the proplist and assign it to a new variable.\r\nOne way to accomplish that is to use `proplists:delete/2`:\r\n\r\n    NewProplist = proplists:delete(foo, Proplist).\r\n\r\n    1> Proplist = [{foo, 42}, {bar, true}, {qux, \"Hello!\"}].\r\n    [{foo,42},{bar,true},{qux,\"Hello!\"}]\r\n    2> NewProplist = proplists:delete(foo, Proplist).\r\n    [{bar,true},{qux,\"Hello!\"}]\r\n\r\nNow we are going to assert that Proplist does not match NewProplist like this:\r\n\r\n    Proplist =/= NewProplist.\r\n\r\n    3> Proplist =/= NewProplist.\r\n    true\r\n\r\nWatch what happens if I try to assign the NewProplist values to Proplist:\r\n\r\n    4> Proplist = NewProplist.\r\n    ** exception error: no match of right hand side value [{bar,true},\r\n                                                           {qux,\"Hello!\"}]\r\n\r\nHere Erlang tells me I have a `badmatch` - the right hand side \r\n`[{bar,true},{qux,\"Hello!\"}]` does not match the left hand side \r\n`[{foo,42},{bar,true},{qux,\"Hello!\"}]` of my expression.\r\n\r\nIn an application you might see \"in the wild\", immutable bindings are typically\r\nhandled like this:\r\n\r\nremove_bird(RemovalType, BirdProplist) ->\r\n    proplists:delete(RemovalType, BirdProplist).\r\n\r\nno_nuthatch() ->\r\n    BirdsRanked = [{nuthatch, 99}, {robin, 1}, {cardinal, 2}, {sparrow, 3}],\r\n    BirdsRanked0 = remove_bird(nuthatch, BirdsRanked),\r\n    io:format(\"Right thinking people only like ~p~n\", [BirdsRanked0]). \r\n\r\n## Your First Application ##\r\nWe're going to implement fizzbuzz in Erlang.  This is a silly exercise\r\noften used as a basic screen to see if an interview candidate can code\r\n*anything*, even a trivial program.\r\n\r\nThe rules of fizzbuzz are as follows:\r\n\r\nFor a list of integers from 1 to 100:\r\n\r\n* Output \"fizz\" if the number is divisible by 3,\r\n* Output \"buzz\" if the number is divisible by 5,\r\n* Output \"fizzbuzz\" if the number is divisible by both 3 and 5.\r\n\r\nUnfortunately, you cannot define namespaced Erlang functions into the REPL.  So\r\nyou're going to need a text editor which you like.  Start it and open a new\r\nfile named `fizzbuzz.erl`.\r\n\r\n```erlang\r\n-module(fizzbuzz).\r\n\r\n-export([t/0, t/1]).\r\n\r\nt() ->\r\n    t(100).\r\n\r\nt(Limit) when Limit > 0 ->\r\n    fizzbuzz(lists:seq(1, Limit));\r\n\r\nt(_Limit) ->\r\n    erlang:error(badarg).\r\n\r\nfizzbuzz([H | T]) ->\r\n    io:format(\"~b: \", [H]),\r\n    fizzbuzz({H rem 3, H rem 5}),\r\n    io:format(\"~n\", []),\r\n    fizzbuzz(T);\r\n\r\nfizzbuzz([]) ->\r\n    io:format(\"done~n\");\r\n\r\nfizzbuzz({0,0}) ->\r\n    io:format(\"fizzbuzz\", []);\r\n\r\nfizzbuzz({0, _}) ->\r\n    io:format(\"fizz\", []);\r\n\r\nfizzbuzz({_, 0}) ->\r\n    io:format(\"buzz\", []);\r\n\r\nfizzbuzz(_) ->\r\n    ok.\r\n```\r\n\r\nWhen you have saved fizzbuzz.erl to disk, open a new Erlang REPL and then type:\r\n\r\n    1> c(fizzbuzz).\r\n    {ok,fizzbuzz}\r\n    2> fizzbuzz:t().\r\n    1: \r\n    2: \r\n    3: fizz\r\n    4: \r\n    5: buzz\r\n    6: fizz\r\n    7: \r\n    8:   \r\n    9: fizz\r\n    10: buzz\r\n    11: \r\n    12: fizz\r\n    13: \r\n    14: \r\n    15: fizzbuzz\r\n    ...\r\n\r\n## Your Second Application ##\r\nWe're going to build a to do list application.  We will get some experience with the forms of Erlang programming including thinking about processes and message passing which are fundamental to understanding how Erlang applications should be designed.\r\n\r\nThe first thing we need to do is set up a directory structure.  The Erlang standard is a directory tree like this\r\n\r\n    todolist/\r\n       ├── ebin   <-- where compiled modules and application configuration go\r\n       └── src    <-- where your source code goes\r\n      \r\nSo pick a directory to do your development in and then run\r\n\r\n    mkdir -p todolist/src todolist/ebin\r\n    \r\n\r\n[0]: https://www.erlang-solutions.com/downloads/download-erlang-otp\r\n[1]: https://github.com/spawngrid/kerl\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}